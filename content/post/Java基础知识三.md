---
title: "Java基础知识(三)"
date: 2019-07-19T09:37:23+08:00
draft: false
categories: ["Java"]
tags: ["Java"]
lastmod: 2019-07-19T09:37:23+08:00
---

## 1、接口和抽象类的区别是什么？

1. 接口的方法默认是public，所有方法在接口中不能有实现（Java8开始接口方法可以有默认实现）。而抽象类可以有非抽象的方法

2. 接口中除了static、final变量，不能有其他变量，而抽象类中不一定

3. 一个类可以实现多个接口，但只能实现一个抽象类。接口自己本身可以通过extends关键字扩展多个接口

4. 接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了重写所以不能使用private关键字修饰！）

5. 从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。

**备注** 在JDK8中，接口可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，
不然会报错

>**关于抽象类**

>JDK1.8以前，抽象类的方法默认访问权限为protected

>JDK1.8时，抽象类的方法默认访问权限变为default

>**关于接口**

>JDK1.8以前，接口中的方法必须是public的

>JDK1.8时，接口中的方法可以时public，也可以是default

>JDK1.9时，接口中的方法可以时private

## 2、成员变量和局部变量的区别有哪些？

1. 从语法形式上看: 成员变量是属于类的，而局部变量是在方法中定义的变量或是方法的参数；成员变量可以被public、private、static等修饰符修饰。而局部变量不能被访问控制修饰符及static所修饰。但是成员变量和局部变量都能被final所修饰

2. 从变量在内存中的存储方式来看：如果成员变量使用static修饰，成员变量属于类。如果没有使用static修饰，成员变量属于实例。对象存在于堆内存，局部变量存在于栈内存

3. 从变量在内存中的生存时间上看：成员变量是对象的一部分，它随着对象的创建而存在。局部变量随着方法的调用而自动消失

4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值。（例外：被final修饰的成员变量也必须显示地赋值）。而局部变量不会自动赋值。

## 3、创建一个对象用什么运算符？对象实体与对象引用有何不同

new运算符，new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。

一个对象引用可以指向0个或1个对象（一根绳子可以不系气球，也可以系一个气球🎈）；一个对象可以有n个引用指向它（可以用n条绳子系住一个气球🎈）

## 4、什么是方法的返回值？返回值在类的方法里的作用是什么？

方法的返回值是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。

返回值的作用：接收结果，应用于其他操作。

## 5、一个类的构造方法的作用是什么？若一个类没有声明构造方法，该程序能正确执行吗？为什么？

主要作用是完成对类对象的初始化工作。

可以执行，因为一个类即使没有声明构造方法，也会有默认的不带参数的构造方法。

详细见[不带参数的构造方法](http://wqwang08.com/post/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BA%8C/#7-%E5%9C%A8java%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8)

## 6、构造方法有哪些特性？

1. 名字与类名相同

2. 没有返回值，但不能用void声明构造函数

3. 生成类的对象时自动执行，无需调用

## 7、静态方法和实例方法有何不同

1. 在外部调用静态方法时，可以使用`类名.方法名`的方式，也可以使用`对象名.方法名`的方式。而实例方法只有后面这种方式，也就是说，调用静态方法可以无需创建对象

2. 静态方法在访问本类的成员时，只允许访问静态成员（静态成员变量和静态方法），而不允许访问实例成员变量和实例方法；实例方法没有这个限制。

## 8、对象的相等与指向他们的引用相等，两者有什么不同

对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等

## 9、在调用子类构造方法之前会先调用父类没有参数的构造方法，目的是？

帮助子类做初始化工作

详细见[不带参数的构造方法](http://wqwang08.com/post/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E4%BA%8C/#7-%E5%9C%A8java%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E4%B8%8D%E5%81%9A%E4%BA%8B%E4%B8%94%E6%B2%A1%E6%9C%89%E5%8F%82%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%9C%E7%94%A8)

## 10、== 与 equals (**重要**)

`==` 它的作用是判断两个对象的地址是不是相等。即，判断两个对象是不是同一个对象（基本数据类型`==`比较的是值,引用数据类型`==`比较的是内存地址）

`equals()` 它的作用也是判断两个对象是否相等。但它一般有两种情况：

* 情况1：类没有覆盖equals()方法。`equals()`等价于通过`==`比较这两个对象

* 情况2: 类覆盖了`equlas()`方法。比较两个对象的内容是否相等，相等返回true

**例子**
```java
public class test {
    public static void main(String[] args) {
        String a = new String("ab"); //a为一个引用
        String b = new String("ab"); //b为另一个引用，对象的内容一样
        String aa = "ab"; //放在常量池中
        String bb = "ab"; //从常量池中查找
        if(aa == bb) //true
            System.out.println("aa==bb");
        if(a == b) //false
            System.out.println("a==b")
        if(a.equals(b)) //true
            System.out.println("aEQb");
        if(42 == 42.0)  //true
            System.out.println("true");
    }
}
```



---
[参考资料](https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/Java基础知识.md)

